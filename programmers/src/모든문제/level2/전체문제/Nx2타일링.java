package 모든문제.level2.전체문제;

public class Nx2타일링 {

    /**
     * [ 문제 설명 ]
     * 가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다.
     * 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다.
     * 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.
     *  - 타일을 가로로 배치 하는 경우
     *  - 타일을 세로로 배치 하는 경우
     * 예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다.
     * 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.
     */

    /**
     * [ 제한 사항 ]
     * 가로의 길이 n은 60,000이하의 자연수 입니다.
     * 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요.
     */
    private static final int MOD = 1000000007;

    public int solution(int n) {
        // TODO: 피보나치 수열을 사용하면 쉽게 풀리는지 몰랐음. 다시 한 번 풀어보자.
        /**
         * 1. n이 1일 때는 타일을 1가지 방법으로만 배치할 수 있으므로, 1을 반환합니다.
         * 2. n이 2 이상일 때, 타일을 배치하는 방법의 수를 저장할 배열 dp를 선언합니다.
         *      이 배열의 각 원소 dp[i]는 가로 길이가 i인 바닥을 타일로 채우는 방법의 수를 나타냅니다.
         * 3. dp[1]과 dp[2]는 각각 1과 2로 초기화됩니다.
         *      이는 가로 길이가 1과 2일 때의 타일 배치 방법의 수를 나타냅니다.
         * 4. n이 3 이상일 경우, dp[i]는 dp[i - 1] + dp[i - 2]로 계산됩니다.
         *      이는 앞서 설명한 피보나치 수열의 성질을 활용한 것입니다.
         * 5. 최종적으로 dp[n]을 반환합니다. 이 값은 가로 길이가 n인 바닥을 타일로 채우는 방법의 수를 나타냅니다.
         *      결과가 매우 클 수 있으므로, 모든 계산은 MOD로 나눈 나머지를 사용하여 수행됩니다.
         */
        if (n == 1) return 1;

        int[] dp = new int[n + 1];
        dp[1] = 1;  // 가로 길이가 1일 때 타일을 채우는 방법은 1가지
        dp[2] = 2;  // 가로 길이가 2일 때 타일을 채우는 방법은 2가지

        for (int i = 3; i <= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;
        }

        return dp[n];
    }

    public static void main(String[] args) {
        Nx2타일링 tiling = new Nx2타일링();

        System.out.println("tiling = " + tiling.solution(4));
    }
}
